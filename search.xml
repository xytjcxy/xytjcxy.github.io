<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[感谢华为]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%84%9F%E8%B0%A2%E5%8D%8E%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[今天，看一部纪录片，叫做美国工厂。里面的美国工厂，其实是中国人开的，叫福耀集团。这个集团，打死不成立工会。因为一旦成立了工会，整个工厂，就不再属于董事长进行管理了。而要被工会插足。 企业刚成立，一年亏损四千万美元，怎么填？如果这时候还各种给员工发福利，养着一帮懒虫，怎么填这个坑？ 其实我真的找不到一个拒绝华为的理由。华为，工资没话说，工作环境没话说，身边的同事优秀的没话说。我真的，没有理由拒绝呀！]]></content>
      <tags>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为实习复盘分析]]></title>
    <url>%2F2019%2F08%2F24%2F%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[华为实习复盘分析眨眼之间，两个月的华为实习就结束了。纵有千般不舍，然天下无不散之筵席，该分别时还是得分别。这两个月的实习，可谓干货满满，我甚至怀疑，人生未来的道路，还能不能有像这两个月这么快乐的成长了。 华为教会我的有很多，可以总结如下：1）沟通合作 2）PPT制作与展示 3）做人与做事 4）高效学习 1. 沟通合作华为里面，最喜欢的事情就是拉通对齐，每当接到一个新的需求，几个部门的大佬首先要花很长时间进行拉通对齐，思想统一，然后才会开展任务。华为优秀的人有很多，干起事情来都很快。但是，每一个伟大的成果，都一定不是单个小团队完成的。而一旦涉及到成百上千的多人协作，必然只有将大家思想统一了，才不会有事后返工，导致效率低下。这，大概就是磨刀不误砍柴工吧！ 总结：涉及到多人协作的工作，一定不要吝惜和别人思想拉通对齐的时间，工欲善其事必先利其器！ 2. PPT制作与展示其实我研究生生涯的前半段算是蛮惨的，一直到19年之前，我都没有开过一次组会，更别提在别人面前展示自己了。长期没有练习自我展示，导致自己的ppt制作能力，演讲能力，都十分潳弱。而由于自小就受到文学作品的影响，对于那些擅长展示的人，也一直没有好感。可是，这个社会，是需要被引导的，而引导，需要展示！ 以前做ppt的时候常常很装逼，自以为字越少越好，然后自信满满的觉得，到时候只需要自己临场发挥即可。一直沉浸在自己的简洁之美中。可是，真正的现实是，本身就不是一块擅长临场发挥的料，在需要展示自己工作量的场合，怎么可能对着一张单薄的ppt，滔滔不绝呢？对于展示自己成果的场合，就应当将自己做了什么，都事无巨细的展示出来，同时，只对自己做的，有价值的方面，进行一带而过的讲解。如果它足够吸引别人眼球，自然会有人提问的！ 单薄的ppt是永远得不到别人尊重的，只有干货满满的ppt，才会吸引别人眼球，博得他人尊重。而只有你做的得到了他人的认可，才能推广你的成果！其次就是展示。每一次展示，都应该将自己的讲稿烂熟于心。可是我，直到答辩前的最后一天，都还在修改讲稿，又怎么能做到烂熟于心呢？想想自己从小就讨厌背书，对于死记硬背的人，天然鄙视。可是，语言方面的学习，最好的捷径就是背书！因为背的不熟，导致是演讲过程要么语速过快，别人听不懂。要么就是磕磕绊绊，总有停顿。 这份ppt，如果做得好，可以多2k的月薪呀。可是到最后，无论师父如何帮忙，效果总还是那么不尽人意~ 总结：ppt的制作内容一定要多，将自己的成果展示出来。然而演讲的时候，只需挑重点的，有把握的讲解。对于值钱的演讲，演讲稿一定要背的烂熟于心。剩下的，就是对演讲进行发音练习了！ 3. 做人做事做人，我觉得我是蛮失败的。不知道是因为自己对朋友要求太高，还是因为自己性格太高冷，长久以来，能真正进入我内心的朋友，高中两个，大学两个，研究生三个。朋友，一直对我是一个奢侈品，他们的每一个，我都很珍惜！ 但对周围的其他人，我似乎一直都很高冷。可是，我和他们的快乐，并不相通呀！上周看哪吒的时候，最触动我的一幕其实是敖丙和哪吒在沙滩上踢毽子的一幕。当时，我突然感觉，既然自己喜欢天才，那么就只有让自己成为天才，才能和他们在同一频道上玩耍。和那些每天浑浑噩噩的人在一起，真的玩不动。 但这也无法掩饰我对教人的不耐烦。在华为实习的两个月，我遇到了很多问题，很多都是通过请教周围同事才最后找到答案的，想想自己以前还挺乐意教人的，现在不愿意去教，大概是因为自从转行后，对自己做的很多东西，都没有把握吧！ 但是，即时不愿意去教别人，也要尝试去关心一下周围其他人呀，只有互相帮助，才会有一个融洽的团队氛围。这，不正是自己所期待的工作环境吗？ 做事，我也觉得我以前很多事都做的不好。可能因为某些原因，自己一直不够有担当。自从开始独居，不自觉的回想起了很多过去的往事。曾经，我也遇到过两位想共度余生的女生。可惜，最后都错过了！第一位，两情相悦。只可惜，我当时一直没有面对未来的勇气，总是在想如果在一起会怎么怎么样。作为男人，我始终少了一份担当的勇气。因为少了这份魄力，我，错过了一段真挚美好的感情。我曾无数次回想起当年一起相处的情景，然后一次次告诉自己在当时那种场景下，我真的没的选。可是，在实习期间，当自己真的开始冷静独处了一段时间后，我才发现，自己，真的少了一份担当。对未知始终有一份莫名的恐惧。可是，纵使未来很难，难道我就不能解决吗？人这一生，能遇到一个自己喜欢的，同时也喜欢自己的另一半，实在是太难了，可遇而不可求！男人应该有担当，是我缺少的素养！第二位，刚开始对我很好，大家彼此都聊的很开心，可故事发展到后面，由于我没有珍惜那唯一一次的约会机会，最终导致了现在的局面。在第一次，也是最后一次和她相约游玩的时候，我居然满脑子想着下次玩什么，对这一次的约会，居然完全不做计划。我呀，真的拜托把当前事务做好后，再去想下一件事吧！想想自己，一直以还有很多事要做为借口，没有把手头的事做的尽善尽美。其实本来这次答辩的CI出bin，我是可以有很好结果的，可是最后因为自己懒，自己不愿意对CI体系深入了解，导致最后一天仓皇补救，最终的结果，也没有达到自己的预期。你，本可以做的更好的！只有一件事做好了，才有资格去做下一件事。一阶段，只做好一件事！ 总结：做人，对身边自己好的人，其实真的要多去关心一下的。关心别人，并不丢脸！做事，请多一份担当，请对自己做的每一件事都负责，请把每一件事都做好后，再去做下一件事！ 4. 高效学习这个标题叫做高效学习，但人世间的成功，哪有捷径可走？要想做的比别人好，就一定得投入比别人多的时间。但有一点是所有优秀的人的共识——总结！以前，我总是不喜欢总结。一件事做完以后，觉得早上时间太宝贵，不能拿来总结。嫌弃下午没睡好，不去总结。觉得晚上太累，不愿总结。周而复始，做的事情再多，由于缺少总结，事半功倍，因此做的事情大多很低端！ 总结：世间再没有什么事情比学习更简单了。投入足够多的时间，每一阶段做好总结，每日三省吾身，即可！]]></content>
      <tags>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1157 通过随机数来碰运气过OJ]]></title>
    <url>%2F2019%2F08%2F11%2F%E9%80%9A%E8%BF%87%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%9D%A5%E7%A2%B0%E8%BF%90%E6%B0%94%E8%BF%87OJ%2F</url>
    <content type="text"><![CDATA[思路： 本题我之前想过是否有什么方法可以过，但似乎没有必定正确的方法。如果有，应该也只是c++和Java的暴力法能过了。 一个取巧的方法，随机在left和right中取100个数，记录这100个数的出现次数。如果数的种类超过3个，只有出现次数大于10的才去判断是否大于阈值。如果种类小于3个，则所有的数都参与判断。 时间复杂段300 O(log n) 12345678910111213141516171819202122232425262728293031import collectionsimport randomimport bisectclass MajorityChecker: def __init__(self, arr): self.array = arr self.arr = collections.defaultdict(list) for i in range(len(arr)): self.arr[arr[i]].append(i) def query(self, left: int, right: int, threshold: int) -&gt; int: a = collections.defaultdict(int) for i in range(100): p = self.array[random.randint(left, right)] a[p] += 1 keys = [] if len(a.keys()) &gt; 3: for k in a.keys(): if a[k] &gt; 10: keys.append(a[k]) else: keys = a.keys() for k in keys: l = bisect.bisect(self.arr[k], left - 1) r = bisect.bisect(self.arr[k], right) if r - l &gt;= threshold: return k return -1]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1156 需要通过观察找出规律]]></title>
    <url>%2F2019%2F08%2F11%2F1156-%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87%E8%A7%82%E5%AF%9F%E6%89%BE%E5%87%BA%E8%A7%84%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[思路：本题如果要实现字符串长度增长，只需要考虑两种场景。 aaabaaa，对于b，左和右相等，这时候，总长度是len(left)+len(right)+int(total(a)&gt;current(a)) aaabba，对于a，长度为len(a)+int(total(a)&gt;current(a)) 因此，代码如下 123456789class Solution: def maxRepOpt1(self, text: str) -&gt; int: grap = [[c,len(list(v))] for c,v in itertools.groupby(text)] num = collections.Counter(text) res = max(min(k+1,num[c])for c,k in grap) for i in range(1,len(grap)): if grap[i][1]==1 and i+1 != len(grap) and grap[i-1][0]==grap[i+1][0]: res = max(res,min(grap[i-1][1]+grap[i+1][1]+1,num[grap[i-1][0]])) return res]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1146 二分查找]]></title>
    <url>%2F2019%2F08%2F04%2FLeetCode-1146-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[思路： 数组保存所有数。同时，每个set只记录增量，通过二分查找得到最近snap的数。 关键点，对于没有set的数，即使snap了，也和上一个snap_id是一样的。 12345678910111213141516171819# 这里之所以要用float('inf')的原因是，这样当出现第一项相同时，必然往后靠import bisectclass SnapshotArray: def __init__(self, length: int): self.snaps = [[[-1,0]] for i in range(length)] self.snap_id = 0 def set(self, index: int, val: int) -&gt; None: self.snaps[index].append([self.snap_id,val]) def snap(self) -&gt; int: self.snap_id+=1 return self.snap_id-1 def get(self, index: int, snap_id: int) -&gt; int: idx = bisect.bisect_right(self.snaps[index],[snap_id,float('inf')])-1 return self.snaps[index][idx][1]]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git获取指定svn版本的代码]]></title>
    <url>%2F2019%2F08%2F03%2Fgit%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9Asvn%E7%89%88%E6%9C%AC%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍如何通过git，获取svn指定版本号的代码 svn的下载、安装、配置参见https://blog.csdn.net/WinstonLau/article/details/79794967 对同一个项目同时使用svn参见https://blog.csdn.net/zzxiang1985/article/details/75212244 本文是因为项目需要，所以必须将svn的版本号和git的节点号对齐。如果你刚开始创建自己的项目，建议还是使用git，毕竟这是主流，同时也方便离线提交代码！ 在git仓库中与远程的svn仓库关联1234# -r 1:HEAD,表示更新从版本1到最新版本的svn仓库# svn://localhost,表示svn远程仓库的url# .,表示将clone的svn更新到当前文件夹下git svn clone -r 1:HEAD svn://localhost . git查询指定svn版本对应的节点假设我想查询r4对应的git节点号 12git svn reset r4# 会显示：r4 = 4945ec51baa115ecce9b7fdf78aa8ae716345855 (refs/remotes/git-svn) 将git回退至指定版本1git reset --hard 4945ec51baa115ecce9b7fdf78aa8ae716345855 将git由当前svn版本更新至最新svn版本1234# git查询当前svn所属版本号，比如我当前是4git svn log# 将git更新至svn最新节点git svn fetch -r 4:HEAD]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1140 化整为零的DP求解思路]]></title>
    <url>%2F2019%2F07%2F28%2F%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6%E7%9A%84DP%E6%B1%82%E8%A7%A3%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[思路：本题是要求解在1:n的石子堆内，先出手者的最大收益。 dp(i,j)表示，i:n的石子堆内，先出手者的最大收益。 代码：1234567891011121314151617181920212223class Solution: def stoneGameII(self, piles: List[int]) -&gt; int: piles.insert(0, 0) n = len(piles) for i in range(1, n): piles[i] += piles[i - 1] a = [[0] * n for i in range(n)] def dp(i, j): if n - i &lt;= 2 * j: return piles[n - 1] - piles[i - 1] if a[i][j] &gt; 0: return a[i][j] for k in range(2 * j): if i + k &gt;= n: break if a[i][j] == 0: a[i][j] = piles[n - 1] - piles[i - 1] - dp(i + k + 1, max(k + 1, j)) else: a[i][j] = max(a[i][j], piles[n - 1] - piles[i - 1] - dp(i + k + 1, max(k + 1, j))) return a[i][j] return dp(1, 1) 反思：dp问题分两种，1）每增加一项，寻找第i项与第i-1项之间的递推关系。2）将大的范围，逐渐减小至小范围，临界条件已知，最后求解大范围处的值。]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scons介绍]]></title>
    <url>%2F2019%2F07%2F28%2FScons%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Scons介绍1 简介Scons是一个python写的编译工具，与makefile功能类似，但能兼容makefile，同时更加智能，可以自动解析系统的include路径、typedef等。 2 Scons文件1）配置文件：与scons命令位于同一目录下的SConstruct、Sconstruct、sconstruct文件 2）SConstruct使用函数SConscript()来定附属配置文件，这些附属配置文件被命名为SConscript。附属配置文件将脚本内的目标文件编译后传给SConstruct 学习参考：https://blog.csdn.net/sealyao/article/details/6402257]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为实习——痛苦&快乐]]></title>
    <url>%2F2019%2F07%2F27%2F%E7%97%9B%E8%8B%A6%E5%B9%B6%E5%BF%AB%E4%B9%90%E7%9A%84%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[这周的心情，应该算是跌入谷底了吧。一篇杂谈，吐槽我低落的心情~ 师父让我做一个自动出bin的工具，思路很简单，但当所有的需求都完成后，我居然花了一周。 今年华为的校招形势比往年都严峻，我不清楚我得多努力才能被认可，才能被留用。 在华为每天准点下班，居然被师父怼了。他对我的训斥，记忆犹新——命运要掌握在自己的手里，不要交给运气。如果你不好好干，就回去继续搞土木吧！ 之前一直以为答辩时间早8月底，所以就一直很放松。但没想到提前到8月中旬了。时间不等人，我得马上进入备考状态了！ 之前答应老师的一篇论文，估计8月底写不出来了。成果都有了，但如果让我现在分心去写论文，我做不到。上次面试阿里的悲剧，我绝不要重复！ LTE的那本书总算到了，接下来得要好好准备复习之前所学的内容了。 如果我们组今年只招1个，我一定要努力到，能留用的那1个就是我！I am the best, others are trashes!]]></content>
      <tags>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1131 最远曼哈顿距离]]></title>
    <url>%2F2019%2F07%2F21%2FLeetCode1131-%E6%9C%80%E8%BF%9C%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目：给你两个长度相等的整数数组，返回下面表达式的最大值： 1|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| 其中下标 i，j 满足 0 &lt;= i, j &lt; arr1.length。 思路：其实这道题的引申问题也就是求最远曼哈顿距离。而最远曼哈顿距离也可以引申为新增一个点，求该点到一群点的最大曼哈顿距离。 最大曼哈顿距离的求解方法： 1234|x1 - x2| + |y1 - y2| 等价于 x1-x2 + y1-y2 (1,1), -x1+x2 + -y1+y2 (-1,-1), x1-x2 + -y1+y2 (1,-1), -x1+x2 + y1-y2 (-1,1) 也就等价于 (x1,y1)-(x2,y2),(-(x1,y1))-(-(x2,y2)),(x1,-y1)-(x2,-y2),(-x1,y1)-(-x2,y2)最后的最大距离的点，必然是位于这四种情况中的某一种，因此对于每种情况，保留其中的min坐标，对于新加入的点，若为最大，必然是减去min坐标 12345678910class Solution: def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -&gt; int: res = 0 for i, j in [[1, 1], [1, -1], [-1, -1], [-1, 1]]: close = arr1[0] * i + arr2[0] * j for k in range(1, len(arr1)): p = arr1[k] * i + arr2[k] * j + k res = max(res, p - close) close = min(close, p) return res 反思：这道题其实很有借鉴意义，因为之前面试的时候就遇到过这道题，结果没有做出来。原来就是四种情况，每次保存每种情况最小的那个坐标即可。]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1130-DP]]></title>
    <url>%2F2019%2F07%2F20%2Fleetcode1130%2F</url>
    <content type="text"><![CDATA[leetcode 1130 思路: dp[i,j]=min(dp[i,k]+dp[k+1,j]+max(arr[i:k+1])*max(arr[k+1:j+1]) 因此，直接使用dp函数求解 12345678910111213141516class Solution: def mctFromLeafValues(self, arr: List[int]) -&gt; int: a = [[0] * len(arr) for i in range(len(arr))] def dp(i, j): if i == j: return 0 if a[i][j] != 0: return a[i][j] res = float('inf') for k in range(i, j): res = min(res, dp(i, k) + dp(k + 1, j) + max(arr[i:k + 1]) * max(arr[k + 1:j + 1])) a[i][j] = res return res return dp(0, len(arr) - 1) 反思：因为很久没有做leetcode的题目了，结果这道这么简单的题都没有做出来，是时候反省一下自己了。为什么最近自己总是想着玩，没有认真对待自己的代码。对于coder而言，代码就是自己的尊严呀！]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
