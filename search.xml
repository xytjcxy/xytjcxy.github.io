<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 1157 通过随机数来碰运气过OJ]]></title>
    <url>%2F2019%2F08%2F11%2F%E9%80%9A%E8%BF%87%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%9D%A5%E7%A2%B0%E8%BF%90%E6%B0%94%E8%BF%87OJ%2F</url>
    <content type="text"><![CDATA[思路： 本题我之前想过是否有什么方法可以过，但似乎没有必定正确的方法。如果有，应该也只是c++和Java的暴力法能过了。 一个取巧的方法，随机在left和right中取100个数，记录这100个数的出现次数。如果数的种类超过3个，只有出现次数大于10的才去判断是否大于阈值。如果种类小于3个，则所有的数都参与判断。 时间复杂段300 O(log n) 12345678910111213141516171819202122232425262728293031import collectionsimport randomimport bisectclass MajorityChecker: def __init__(self, arr): self.array = arr self.arr = collections.defaultdict(list) for i in range(len(arr)): self.arr[arr[i]].append(i) def query(self, left: int, right: int, threshold: int) -&gt; int: a = collections.defaultdict(int) for i in range(100): p = self.array[random.randint(left, right)] a[p] += 1 keys = [] if len(a.keys()) &gt; 3: for k in a.keys(): if a[k] &gt; 10: keys.append(a[k]) else: keys = a.keys() for k in keys: l = bisect.bisect(self.arr[k], left - 1) r = bisect.bisect(self.arr[k], right) if r - l &gt;= threshold: return k return -1]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1156 需要通过观察找出规律]]></title>
    <url>%2F2019%2F08%2F11%2F1156-%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87%E8%A7%82%E5%AF%9F%E6%89%BE%E5%87%BA%E8%A7%84%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[思路：本题如果要实现字符串长度增长，只需要考虑两种场景。 aaabaaa，对于b，左和右相等，这时候，总长度是len(left)+len(right)+int(total(a)&gt;current(a)) aaabba，对于a，长度为len(a)+int(total(a)&gt;current(a)) 因此，代码如下 123456789class Solution: def maxRepOpt1(self, text: str) -&gt; int: grap = [[c,len(list(v))] for c,v in itertools.groupby(text)] num = collections.Counter(text) res = max(min(k+1,num[c])for c,k in grap) for i in range(1,len(grap)): if grap[i][1]==1 and i+1 != len(grap) and grap[i-1][0]==grap[i+1][0]: res = max(res,min(grap[i-1][1]+grap[i+1][1]+1,num[grap[i-1][0]])) return res]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谁偷了我的理想]]></title>
    <url>%2F2019%2F08%2F09%2F%E8%B0%81%E5%81%B7%E4%BA%86%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3%2F</url>
    <content type="text"><![CDATA[名字首拼 U2FsdGVkX19Qu2bwvc2o+weRnJvVaHL226hk3iOdfPJSx58g008FSzcpRXsyVctj2J26Afzydj8rjA7QvQjhIup1oz2cBd3Um//ISBdTYlobes9jPw3eRJbIjPirHszxr+uSrWpsTwev3+yQK7EjUQ==]]></content>
      <tags>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1146 二分查找]]></title>
    <url>%2F2019%2F08%2F04%2FLeetCode-1146-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[思路： 数组保存所有数。同时，每个set只记录增量，通过二分查找得到最近snap的数。 关键点，对于没有set的数，即使snap了，也和上一个snap_id是一样的。 12345678910111213141516171819# 这里之所以要用float('inf')的原因是，这样当出现第一项相同时，必然往后靠import bisectclass SnapshotArray: def __init__(self, length: int): self.snaps = [[[-1,0]] for i in range(length)] self.snap_id = 0 def set(self, index: int, val: int) -&gt; None: self.snaps[index].append([self.snap_id,val]) def snap(self) -&gt; int: self.snap_id+=1 return self.snap_id-1 def get(self, index: int, snap_id: int) -&gt; int: idx = bisect.bisect_right(self.snaps[index],[snap_id,float('inf')])-1 return self.snaps[index][idx][1]]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[落泪的星期六]]></title>
    <url>%2F2019%2F08%2F04%2F%E8%90%BD%E6%B3%AA%E7%9A%84%E6%98%9F%E6%9C%9F%E5%85%AD%2F</url>
    <content type="text"><![CDATA[名字首拼 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]]></content>
      <tags>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git获取指定svn版本的代码]]></title>
    <url>%2F2019%2F08%2F03%2Fgit%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9Asvn%E7%89%88%E6%9C%AC%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍如何通过git，获取svn指定版本号的代码 svn的下载、安装、配置参见https://blog.csdn.net/WinstonLau/article/details/79794967 对同一个项目同时使用svn参见https://blog.csdn.net/zzxiang1985/article/details/75212244 本文是因为项目需要，所以必须将svn的版本号和git的节点号对齐。如果你刚开始创建自己的项目，建议还是使用git，毕竟这是主流，同时也方便离线提交代码！ 在git仓库中与远程的svn仓库关联1234# -r 1:HEAD,表示更新从版本1到最新版本的svn仓库# svn://localhost,表示svn远程仓库的url# .,表示将clone的svn更新到当前文件夹下git svn clone -r 1:HEAD svn://localhost . git查询指定svn版本对应的节点假设我想查询r4对应的git节点号 12git svn reset r4# 会显示：r4 = 4945ec51baa115ecce9b7fdf78aa8ae716345855 (refs/remotes/git-svn) 将git回退至指定版本1git reset --hard 4945ec51baa115ecce9b7fdf78aa8ae716345855 将git由当前svn版本更新至最新svn版本1234# git查询当前svn所属版本号，比如我当前是4git svn log# 将git更新至svn最新节点git svn fetch -r 4:HEAD]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1140 化整为零的DP求解思路]]></title>
    <url>%2F2019%2F07%2F28%2F%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6%E7%9A%84DP%E6%B1%82%E8%A7%A3%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[思路：本题是要求解在1:n的石子堆内，先出手者的最大收益。 dp(i,j)表示，i:n的石子堆内，先出手者的最大收益。 代码：1234567891011121314151617181920212223class Solution: def stoneGameII(self, piles: List[int]) -&gt; int: piles.insert(0, 0) n = len(piles) for i in range(1, n): piles[i] += piles[i - 1] a = [[0] * n for i in range(n)] def dp(i, j): if n - i &lt;= 2 * j: return piles[n - 1] - piles[i - 1] if a[i][j] &gt; 0: return a[i][j] for k in range(2 * j): if i + k &gt;= n: break if a[i][j] == 0: a[i][j] = piles[n - 1] - piles[i - 1] - dp(i + k + 1, max(k + 1, j)) else: a[i][j] = max(a[i][j], piles[n - 1] - piles[i - 1] - dp(i + k + 1, max(k + 1, j))) return a[i][j] return dp(1, 1) 反思：dp问题分两种，1）每增加一项，寻找第i项与第i-1项之间的递推关系。2）将大的范围，逐渐减小至小范围，临界条件已知，最后求解大范围处的值。]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scons介绍]]></title>
    <url>%2F2019%2F07%2F28%2FScons%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Scons介绍1 简介Scons是一个python写的编译工具，与makefile功能类似，但能兼容makefile，同时更加智能，可以自动解析系统的include路径、typedef等。 2 Scons文件1）配置文件：与scons命令位于同一目录下的SConstruct、Sconstruct、sconstruct文件 2）SConstruct使用函数SConscript()来定附属配置文件，这些附属配置文件被命名为SConscript。附属配置文件将脚本内的目标文件编译后传给SConstruct 学习参考：https://blog.csdn.net/sealyao/article/details/6402257]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为实习——痛苦&快乐]]></title>
    <url>%2F2019%2F07%2F27%2F%E7%97%9B%E8%8B%A6%E5%B9%B6%E5%BF%AB%E4%B9%90%E7%9A%84%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[这周的心情，应该算是跌入谷底了吧。一篇杂谈，吐槽我低落的心情~ 师父让我做一个自动出bin的工具，思路很简单，但当所有的需求都完成后，我居然花了一周。 今年华为的校招形势比往年都严峻，我不清楚我得多努力才能被认可，才能被留用。 在华为每天准点下班，居然被师父怼了。他对我的训斥，记忆犹新——命运要掌握在自己的手里，不要交给运气。如果你不好好干，就回去继续搞土木吧！ 之前一直以为答辩时间早8月底，所以就一直很放松。但没想到提前到8月中旬了。时间不等人，我得马上进入备考状态了！ 之前答应老师的一篇论文，估计8月底写不出来了。成果都有了，但如果让我现在分心去写论文，我做不到。上次面试阿里的悲剧，我绝不要重复！ LTE的那本书总算到了，接下来得要好好准备复习之前所学的内容了。 如果我们组今年只招1个，我一定要努力到，能留用的那1个就是我！I am the best, others are trashes!]]></content>
      <tags>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1131 最远曼哈顿距离]]></title>
    <url>%2F2019%2F07%2F21%2FLeetCode1131-%E6%9C%80%E8%BF%9C%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目：给你两个长度相等的整数数组，返回下面表达式的最大值： 1|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| 其中下标 i，j 满足 0 &lt;= i, j &lt; arr1.length。 思路：其实这道题的引申问题也就是求最远曼哈顿距离。而最远曼哈顿距离也可以引申为新增一个点，求该点到一群点的最大曼哈顿距离。 最大曼哈顿距离的求解方法： 1234|x1 - x2| + |y1 - y2| 等价于 x1-x2 + y1-y2 (1,1), -x1+x2 + -y1+y2 (-1,-1), x1-x2 + -y1+y2 (1,-1), -x1+x2 + y1-y2 (-1,1) 也就等价于 (x1,y1)-(x2,y2),(-(x1,y1))-(-(x2,y2)),(x1,-y1)-(x2,-y2),(-x1,y1)-(-x2,y2)最后的最大距离的点，必然是位于这四种情况中的某一种，因此对于每种情况，保留其中的min坐标，对于新加入的点，若为最大，必然是减去min坐标 12345678910class Solution: def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -&gt; int: res = 0 for i, j in [[1, 1], [1, -1], [-1, -1], [-1, 1]]: close = arr1[0] * i + arr2[0] * j for k in range(1, len(arr1)): p = arr1[k] * i + arr2[k] * j + k res = max(res, p - close) close = min(close, p) return res 反思：这道题其实很有借鉴意义，因为之前面试的时候就遇到过这道题，结果没有做出来。原来就是四种情况，每次保存每种情况最小的那个坐标即可。]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1130-DP]]></title>
    <url>%2F2019%2F07%2F20%2Fleetcode1130%2F</url>
    <content type="text"><![CDATA[leetcode 1130 思路: dp[i,j]=min(dp[i,k]+dp[k+1,j]+max(arr[i:k+1])*max(arr[k+1:j+1]) 因此，直接使用dp函数求解 12345678910111213141516class Solution: def mctFromLeafValues(self, arr: List[int]) -&gt; int: a = [[0] * len(arr) for i in range(len(arr))] def dp(i, j): if i == j: return 0 if a[i][j] != 0: return a[i][j] res = float('inf') for k in range(i, j): res = min(res, dp(i, k) + dp(k + 1, j) + max(arr[i:k + 1]) * max(arr[k + 1:j + 1])) a[i][j] = res return res return dp(0, len(arr) - 1) 反思：因为很久没有做leetcode的题目了，结果这道这么简单的题都没有做出来，是时候反省一下自己了。为什么最近自己总是想着玩，没有认真对待自己的代码。对于coder而言，代码就是自己的尊严呀！]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
